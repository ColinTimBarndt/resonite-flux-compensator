# Node Model

This document defines how a FluxCompensator node is modeled such
that it can be read by the compiler.

## Examples

The compiler will recognize reads and writes to parameters and when transpiling replace them
by the proper instructions.

```cs
[Action]
Continuation Write<T>(
  [Input] T value,
  [InputRef] ref T variable,
  Continuation next
) {
  variable = value;
  return next;
}
```

It should be possible to leave out the Continuation if the node can only continue, for ergonomics:

```cs
[Action]
void Write<T>(
  [Input] T value,
  [InputRef] ref T variable
) {
  variable = value;
}
```

After transpilation into an impulse, this could look like:

```cs
void MyImpulse() {
  int i;

  // Write (42, &i);
  int temp = 42;
  i = temp;
}
```

Or, if the variable is something like an abstract IVariable:

```cs
[StructLayout(LayoutKind.Explicit)]
ref struct MyContext {
  [FieldOffset(0)] int i;
}

void MyImpulse(ref MyContext ctx) {
  IVariable<int> x = new LocalVariable(offset: 0);

  // Write (42, &x);
  int temp = 42;
  x.Write(ref ctx, temp);
}
```

Note that the "OnFail" continuation is omitted here as it would complicate the implementation.
It may make sense to implement specialization for such special cases where an error needs to be handled,
since not all variables (like locals/stores) can fail to write to:

```cs
[Action]
Continuation Write<T>(
  [Input] T value,
  [InputRef] Variable<T> variable,
  Continuation onSuccess,
  Continuation onError
) {
  return variable.Write(value) ? onSuccess : onError;
}
```

If the variable was passed as an actual input (not a reference as in ProtoFlux), we get the following. Note
that instead of the `IVaraible` interface, a struct `Variable` is used for abstracting over the context access
since the context is generated by the compiler and cannot be accessed in source code.

```cs
[Action]
Continuation IndirectWrite<T>(
  [Input] T value,
  [Input] Variable<T> variable,
  Continuation onSuccess,
  Continuation onError
) {
  return variable.Write(value) ? onSuccess : onError;
}
```

```cs
[Action]
Continuation For(
  [Input] int count,
  [Output] ref int index,
  Call before,
  Call step,
  Continuation next
) {
  before();
  for (index = 0; index < count; index++) {
    step();
  }
  index = 0;
  return next;
}
```

```cs
[Action]
Continuation If(
  [Input] bool condition,
  Continuation onTrue,
  Continuation onFalse
) {
  return condition ? onTrue : onFalse;
}
```

For accessing properties of the runtime context like `FrooxEngineContext` in ProtoFlux, the
following syntax could be used:

```cs
void WorldRoot(
  [Context] World world,
  [Output] ref Slot? slot
) {
  slot = world.RootSlot;
}
```
